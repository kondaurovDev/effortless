---
title: Effortless AWS
description: Code-first AWS Lambda framework. Export handlers, deploy with one command.
template: splash
---

import { Card, CardGrid, LinkButton, Tabs, TabItem } from '@astrojs/starlight/components';
import AnimatedHero from '../../components/AnimatedHero.astro';

<AnimatedHero />

<CardGrid>
  <Card title="Infrastructure from code">
    Export a handler — get the full AWS infrastructure automatically. No YAML, no config files.

    - Export handler — get Lambda, API Gateway, DynamoDB, IAM
    - Auto IAM wiring from `deps: { orders }`
    - Secrets via `param("key")` — fetched from SSM at cold start

    <LinkButton href="/why-effortless/" variant="secondary" icon="right-arrow">Learn more</LinkButton>
  </Card>
  <Card title="Zero overhead deployment">
    Direct AWS SDK calls instead of CloudFormation. No state files to manage. Deploy in seconds, not minutes.

    - Deploy in ~5-10s — direct API calls, no CloudFormation
    - No state files — AWS resource tags as source of truth
    - Smart Lambda Layers with hash-based versioning

    <LinkButton href="/faq/#why-not-cloudformation" variant="secondary" icon="right-arrow">Learn more</LinkButton>
  </Card>
  <Card title="Type safety everywhere">
    One `defineTable<Order>` call creates the table, generates typed clients, and validates data at runtime with Effect Schema.

    - Typed `.put()`, `.get()`, typed stream records
    - Schema validation via Effect Schema before your handler runs
    - One definition — types flow to clients, streams, and deps

    <LinkButton href="/handlers/" variant="secondary" icon="right-arrow">Learn more</LinkButton>
  </Card>
  <Card title="Production ready by default">
    Serverless best practices baked in — inspired by AWS Lambda Powertools. No boilerplate needed.

    - Partial batch failures — bad records don't kill the batch
    - Cold start caching — `context` factory runs once, reused across invocations
    - Execution logging and error tracking via platform table

    <LinkButton href="/architecture/" variant="secondary" icon="right-arrow">Learn more</LinkButton>
  </Card>
</CardGrid>

## Examples

<Tabs>
  <TabItem label="HTTP API">
    ```typescript
    // src/api.ts
    import { defineHttp } from "effortless-aws";

    export const hello = defineHttp({
      method: "GET",
      path: "/hello/{name}",
      onRequest: async ({ req }) => {
        return {
          status: 200,
          body: { message: `Hello, ${req.params.name}!` },
        };
      },
    });
    ```
    Creates: Lambda + API Gateway `GET /hello/{name}` route + IAM role.
  </TabItem>
  <TabItem label="DynamoDB + API">
    ```typescript
    // src/orders.ts
    import { defineTable, defineHttp } from "effortless-aws";

    type Order = { id: string; product: string; amount: number };

    export const orders = defineTable<Order>({
      pk: { name: "id", type: "string" },
      onRecord: async ({ record }) => {
        if (record.eventName === "INSERT") {
          console.log("New order:", record.new!.product);
        }
      },
    });

    export const createOrder = defineHttp({
      method: "POST",
      path: "/orders",
      deps: { orders },
      onRequest: async ({ req, deps }) => {
        await deps.orders.put({
          id: crypto.randomUUID(),
          product: req.body.product,
          amount: req.body.amount,
        });
        return { status: 201, body: { ok: true } };
      },
    });
    ```
    Creates: DynamoDB table with stream + stream processor Lambda + HTTP Lambda with DynamoDB write permissions + API Gateway route. All from one file.
  </TabItem>
  <TabItem label="Static site">
    ```typescript
    // src/site.ts
    import { defineApp } from "effortless-aws";

    export const docs = defineApp({
      path: "/",
      dir: "dist",
      build: "npx astro build",
    });
    ```
    Creates: Lambda that serves static files from `dist/` + API Gateway routes. Runs the build command before deploy. Automatic content-type detection, caching headers, binary file support.
  </TabItem>
</Tabs>

```bash
npx eff deploy
```

## How it works

1. **Static analysis** (ts-morph) — reads your exports, extracts handler config from AST
2. **Bundle** (esbuild) — wraps each handler with a runtime adapter, tree-shaken per function
3. **Deploy** (AWS SDK) — creates/updates Lambda, API Gateway, DynamoDB, IAM directly

No CloudFormation stacks. No Terraform state. Tags on AWS resources are the only state.

## Compared to

| | SST v3 | Nitric | Serverless | **Effortless** |
|---|---|---|---|---|
| Infra from code (not config) | No | Yes | No | **Yes** |
| Typed client from schema | No | No | No | **Yes** |
| No state files | No | No | No | **Yes** |
| Deploy speed | ~30s | ~30s | minutes | **~5-10s** |
| Runs in your AWS account | Yes | Yes | Yes | **Yes** |
| Open source | Yes | Yes | Yes | **Yes** |
